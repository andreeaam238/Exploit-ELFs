Blaga Ana-Maria-Andreea, 324CB

Tema 4 - Exploit ELFs

Task 1 - Analiza binarului

Adresa functiei vulnerabile este 80492f8 <print_flag+0x67>.

Pentru a putea vedea codul din spatele executabilului am folosit comanda:
	objdump -M intel -d nice > nice.dump

De asemenea am folosit atat Ghidra si GDB pentru a analiza binarul.

Am analizat fisierul rezultat pornind din functia <main>. Astfel, am sesizat 
mai multe push-uri ale unor valori pe stiva si cinci call-uri/apeluri de functii.
Am analizat fiecare functie apelata din <main> si am observat ca in cadrul celei 
de a doua functii apelate (call   80492f8 <print_flag+0x67>) se realizeaza un apel
al functiei read care permite citirea a 0x30b/779 bytes in cadrul unui buffer local 
(alocat pe stiva) de dimensiune 0x1e1/481 bytes.

Astfel, putem folosi un string de dimensiune mai mare decat dimensiunea buffer-ului
pentru a genera un buffer overflow, modificand adresa de return a functiei 
vulnerabile cu o adresa dorita de noi (cea a functiei in cadrul careia se afiseaza 
flag-ul: 08049291 <print_flag>).

Task 2 - Spargerea binarului

Flag-ul: NICE_FLAG{b4b002d2da8ae874cd79e6913d2634b5}.

Payload-ul folosit pentru spargerea binarului este generat astfel:
	python -c "print('A' * (161 + 481 + 4) + '\x91' + '\x92' + '\x04' + '\x08')" > nice_payload

Se printeaza caracterul 'A' de (161 + 481 + 4) ori, astfel:
	-> 161 = 0xa1 : numarul maxim de caractere ce pot fi citite in cadrul 
	apelului read din prima functie apelata din main;
		
	-> 481 = 0x1e1 : numar de caractere egal cu dimensiunea bufferului alocat
	in cea de a doua functie apelata din main;
		
	-> 4 : offset pentru a suprascrie valorile pana la valoarea ce va fi folosita
    ca adresa de return a celei de a doua functii apelate din main.

Apoi se printeaza adresa functiei care afiseaza flagul 0x8049291 (08049291 <print_flag>)
in format little endian: '\x91' + '\x92' + '\x04' + '\x08'.

Deoarece buffer-ul alocat in cadrul celei de a doua functii este de dimensiune 
0x1e1 = 481 bytes, iar in cadrul apelului read se pot citi maxim 0x30b = 779 bytes, 
memoria alocata nu este suficienta si vor fi suprascrise alte valori aflate pe 
stiva, in continuarea acestuia. Astfel, suprascriem adresa de return a functiei cu 
adresa functiei care afiseaza flag-ul.

Dupa terminarea executiei celei de-a doua functii, in loc sa se execute urmatoarea 
instructiune din main, se "sare" la executia functiei print_flag si se afiseaza 
flag-ul: NICE_FLAG{b4b002d2da8ae874cd79e6913d2634b5}.

Daca am folosi payload-ul generat cu urmatoarea comanda s-ar afisa "All done! Bye-bye":
	python -c "print('A' * (161 + 481 + 4) + '\xc8' + '\x92' + '\x04' + '\x08')" > nice_payload

Task 3 - Spargerea binarului v2

Adresa functiei vulnerabile este 8049308 <print_flag+0x77>.

Flag-ul: NAUGHTY_FLAG{69e5479029918f6efa81d9c633fc1a51}.

Am procedat asemanator ca in cazul binarului nice: aplicat objdump asupra binarului
si apoi analizat fisierul rezultat incepand din <main>. Am constatat ca se merge 
pe aceeasi idee de apel read in fiecare functie apelata din main si cu posibilitatea 
de bufferoverflow, insa au existat si niste diferente fata de binarul nice. 

De aceasta data am sesizat ca in cadrul celei de-a doua functii apelate din main se 
realizeaza un apel catre o alta functie:
	mov    eax,DWORD PTR [ebp-0xeb]
	call   eax

Astfel, am constatat ca putem folosi un string de dimensiune mai mare decat 
dimensiunea buffer-ului pentru a genera un buffer overflow, modificand adresa 
functiei care se apeleaza cu o adresa dorita de noi (cea a functiei in cadrul 
careia se afiseaza flag-ul: 08049291 <print_flag>).

Payload-ul folosit pentru spargerea binarului este generat astfel:
	python -c "print('A' * 181 + '\x8c' + '\xa6' + '\x82' + '\x59' + 'A' * (14 + 647) + 
					'\x91' + '\x92' + '\x04' + '\x08' + 'A' * 217 + '\x05' + '\x9e' + 
					'\x4e' + '\xad' + 'A' * 10)" > naughty_payload

O diferenta pe care am observat-o fata de binarul nice este faptul ca se realizeaza
o comparatie in plus la fiecare citire. Se compara o valoare aflata pe stiva la un 
anumit offset fata de ebp-ul functiei curente cu o anumita valoare. Daca acestea 
nu sunt egale, se termina executia programului. Concluzionam ca aceste valori
trebuie plasate in buffer la anumite pozitii, astfel incat comparatia sa indice 
egalitate.

Primul buffer se completeaza cu caractere astfel:
	'A' * 181 + '\x8c' + '\xa6' + '\x82' + '\x59' + 'A' * 14

	-> 'A' * 181 = 0xc9 - 0x14 : diferenta dintre dimensiunea buffer-ului si adresa 
	de inceput a valorii de comparat;

	-> '\x8c' + '\xa6' + '\x82' + '\x59' : valoarea de comparat (4 bytes);

	-> 'A' * 14 = 0xc7 - (0xc9 - 0x14) - 0x4 : restul de caractere ramase de citit
	pana la atingerea numarului maxim de caractere ce pot fi citite in cadrul
	apelului read respectiv.

Al doilea buffer se completeaza cu caractere astfel:
	'A' * 647 + '\x91' + '\x92' + '\x04' + '\x08' + 'A' * 217 + '\x05' + '\x9e' + 
		'\x4e' + '\xad' + 'A' * 10

	-> 'A' * 647 = 0x372 - 0xeb: diferenta dintre dimensiunea buffer-ului si adresa 
	la care este stocata adresa functiei care va fi apelata;

	-> '\x91' + '\x92' + '\x04' + '\x08' : adresa functiei print_flag (4 bytes) 
	pentru a fi apelata atunci cand se va executa call eax;

	-> 'A' * 217 =  0x372 - (0x372 - 0xeb) - 0x4 - 0xe: restul caractere pana la
	adresa de inceput a valorii de comparat;

	-> '\x05' + '\x9e' + '\x4e' + '\xad' : valoarea de comparat (4 bytes);

	-> 'A' * 10 : restul de caractere ramase de citit pana la atingerea numarului 
	maxim de caractere ce pot fi citite in cadrul apelului read respectiv. 
	(0x372 = 882 => 882 - 647 - 4 - 217 - 4 = 10).

Cu acesta configuratie comparatiile trec cu succes, iar instructiunea call eax 
determina apelarea functiei print_flag si se afiseaza flag-ul: 
NAUGHTY_FLAG{69e5479029918f6efa81d9c633fc1a51}.
